---
title: Build Tools and Package Manager Tools
type: docs
prev: docs/NanaBootcamo/Module3
next: docs/NanaBootcamo/Module5
sidebar:
  open: true
---
 

### What is an artifact?

An **artifact** is a file produced during a build process. It can be a binary or source bundle used for deploying or distributing an application.

Examples of artifacts include:
- **JAR** files (Java)
- **WAR** files (Java web applications)
- **npm packages** (Node.js)
- **Docker images**

Artifacts are the output of your build pipeline and are essential for packaging and deploying applications.

---

### What is inside a JAR file?

A **JAR (Java ARchive)** file is essentially a ZIP file that contains:

- **Compiled `.class` files**  
- **Resource files** (images, configs, etc.)
- **A manifest file `MANIFEST.MF`**

The manifest file provides metadata such as:
- Main class (entry point)
- Version information
- Dependencies (sometimes)

Different ecosystems use different manifest-like files:
- **Maven**: `pom.xml`
- **Node.js**: `package.json`

These files describe the project structure, dependencies, and build instructions.

---

### What is an artifactory and why do we need it?

An **artifactory** is a repository manager used to store and manage artifacts generated by build tools.

Popular examples:
- **Nexus Repository**
- **JFrog Artifactory**
- **GitHub Packages**

Why we need an artifactory:
- Central storage for build outputs
- Version control for artifacts
- Dependency management
- Secure and reliable distribution of binary files
- Supports multiple repository types (Maven, npm, Docker, PyPI, etc.)

For example, Nexus can store:
- Built JAR/WAR files
- Third-party dependencies
- Docker images
- Helm charts
- Python wheels

---

### Why Docker?

Docker simplifies packaging and running applications by using container images.

Benefits of Docker:
- **Consistency:** Same image runs on any machine (local, CI, or production).
- **Isolation:** Each container runs in its own environment.
- **Simplifies Dev → Test → Prod pipeline:** Same artifact (image) is used everywhere.
- **Reduces number of artifact types:** You can ship one artifact (the Docker image) instead of many language-specific ones.
- **Easy rollbacks:** Versioned images make deployments more controlled and repeatable.

In short, Docker makes applications portable, consistent, and easier to manage across different environments.
